#pragma unmanaged
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

#define FF(a, b, c, d, x, s, ac) { (a) += F ((b), (c), (d)) + (x) + (unsigned long int)(ac); (a) = ROTATE_LEFT ((a), (s)); (a) += (b); }
#define GG(a, b, c, d, x, s, ac) { (a) += G ((b), (c), (d)) + (x) + (unsigned long int)(ac); (a) = ROTATE_LEFT ((a), (s)); (a) += (b); }
#define HH(a, b, c, d, x, s, ac) { (a) += H ((b), (c), (d)) + (x) + (unsigned long int)(ac); (a) = ROTATE_LEFT ((a), (s)); (a) += (b); }
#define II(a, b, c, d, x, s, ac) { (a) += I ((b), (c), (d)) + (x) + (unsigned long int)(ac); (a) = ROTATE_LEFT ((a), (s)); (a) += (b); }
#define HashSize 160


unsigned long int state[4]={0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476};     
unsigned long int count[2] = {0, 0};     
unsigned char buffer[64]; 
unsigned char PADDING[64] = {0x80};

void HashAlgorithm_Transform (unsigned long int state[4], unsigned char block[64]);
//计算新数组大小
int HashAlgorithm_CalculateNewSize (int arraySize,int keySize)
{
	return arraySize + keySize + HashSize;
}
//初始化模块注册加密
void HashAlgorithm_InitializeModule(unsigned char sourceArray[], int sourceSize, unsigned char keyArray[], int keySize)
{
	unsigned char HashArray[HashSize] = {
		0x00,0x24,0xA0,0xF0,0x04,0x80,0x00,0x00,0x94,0x00,0x00,0x00,0x06,0x02,0x00,0xC0,
		0x00,0x24,0x00,0x00,0x52,0x53,0x41,0x31,0x00,0x04,0xE0,0x00,0x01,0xD0,0x01,0xF0,
		0x0F,0x49,0x02,0x90,0x94,0xC7,0x4B,0x2A,0x80,0x63,0x9D,0x50,0xFD,0x23,0x36,0xCF,
		0xBA,0xA0,0x1B,0x5D,0xD3,0x43,0x63,0xDD,0x7A,0xB9,0xF7,0x4E,0xD0,0x20,0xA3,0xFD,
		0x60,0xD5,0x90,0xBA,0xF4,0x54,0x45,0x25,0x08,0x3C,0x68,0xF9,0x54,0x4D,0x1F,0xD9,
		0x34,0xA4,0xC5,0x50,0x81,0xE2,0xA5,0x57,0x58,0x9F,0x3E,0xEF,0xBE,0x74,0xDF,0x56,
		0xDF,0xAF,0x98,0xE8,0xFD,0xB2,0xEF,0x33,0x45,0xC5,0xE9,0xE1,0x1B,0x8C,0x16,0xCD,
		0x06,0x37,0x9C,0x3B,0xAC,0xEA,0x28,0x77,0x55,0x94,0x5E,0x3B,0x7F,0x97,0x07,0xD2,
		0x58,0x1A,0xEF,0x3E,0x74,0xF4,0x23,0x94,0x97,0x4A,0xD7,0x8A,0x99,0xB1,0x6B,0x1D,
		0xA9,0xFF,0xB2,0xFE,0xBA,0x85,0x3A,0x5D,0x4F,0xD1,0x67,0x75,0x79,0x6D,0x85,0x91
	};

	int startIndex = sourceSize - keySize - HashSize;
	for(int index = 0;index < sourceSize;index++)
		sourceArray[index + startIndex] = keyArray[index];

	startIndex = sourceSize - HashSize;
	for(int index = 0;index < HashSize;index++)
		sourceArray[index + startIndex] = HashArray[index];
}

void HashAlgorithm_InitializePassword(unsigned char sourceArray[], int sourceSize, unsigned char keyArray[], int keySize)
{
	unsigned char HashArray[HashSize] = {
		0x00,0x24,0x00,0x00,0x04,0x80,0x00,0x00,0x94,0x00,0x00,0x00,0x06,0x02,0x00,0xC0,//0x00
		0x00,0x24,0x00,0x00,0x52,0x53,0x41,0x31,0x00,0x04,0x00,0x00,0x01,0x00,0x01,0x00,
		0x0F,0x49,0x02,0x9E,0x94,0xC7,0x4B,0x2A,0x8A,0x63,0x9D,0x50,0xFD,0x2F,0x36,0xCF,//0xC0,
		0xBA,0xA0,0x1B,0x5D,0xD3,0x43,0x63,0xDD,0x7A,0xB9,0xF7,0x4E,0xD0,0x20,0xA3,0xFD,
		0x60,0xD5,0x90,0xBA,0xF4,0x54,0x45,0x25,0x08,0x3C,0x68,0xF9,0x54,0x4D,0x1F,0xD9,
		0x34,0xA4,0xC5,0x50,0x81,0xE2,0xA5,0x57,0x58,0x9F,0x3E,0xEF,0xBE,0x74,0xDF,0x56,
		0xDF,0xAF,0x98,0xE8,0xFD,0xB2,0xEF,0x33,0x45,0xC5,0xE9,0xE1,0x1B,0x8C,0x16,0xCD,
		0x06,0x37,0x9C,0x3B,0xAC,0xEA,0x28,0x77,0x55,0x94,0x5E,0x3B,0x7F,0x97,0x07,0xD2,
		0x58,0x1A,0xEF,0x3E,0x74,0xF4,0x23,0x94,0x97,0x4A,0xD7,0x8A,0x99,0xB1,0x6B,0x1D,
		0xA9,0xFF,0xB2,0xFE,0xBA,0x85,0x3A,0x5D,0x4F,0xD1,0x67,0x75,0x79,0x6D,0x85,0x91
	};

	int startIndex = sourceSize - keySize - HashSize;
	for(int index = 0;index < sourceSize;index++)
		sourceArray[index + startIndex] = keyArray[index];

	startIndex = sourceSize - HashSize;
	for(int index = 0;index < HashSize;index++)
		sourceArray[index + startIndex] = HashArray[index];
}

void HashAlgorithm_InitializePassword(unsigned char sourceArray[], int sourceSize)
{
	unsigned char HashArray[HashSize] = {
		0x00,0x24,0x00,0x00,0x04,0x80,0x00,0x00,0x94,0x00,0x00,0x00,0x06,0x02,0x00,0xC0,//0x00
		0x00,0x24,0x00,0x00,0x52,0x53,0x41,0x31,0x00,0x04,0x00,0x00,0x01,0x00,0x01,0x00,
		0x0F,0x49,0x02,0x9E,0x94,0xC7,0x4B,0x2A,0x8A,0x63,0x9D,0x50,0xFD,0x2F,0x36,0xCF,//0xC0,
		0xBA,0xA0,0x1B,0x5D,0xD3,0x43,0x63,0xDD,0x7A,0xB9,0xF7,0x4E,0xD0,0x20,0xA3,0xFD,
		0x60,0xD5,0x90,0xBA,0xF4,0x54,0x45,0x25,0x08,0x3C,0x68,0xF9,0x54,0x4D,0x1F,0xD9,
		0x34,0xA4,0xC5,0x50,0x81,0xE2,0xA5,0x57,0x58,0x9F,0x3E,0xEF,0xBE,0x74,0xDF,0x56,
		0xDF,0xAF,0x98,0xE8,0xFD,0xB2,0xEF,0x33,0x45,0xC5,0xE9,0xE1,0x1B,0x8C,0x16,0xCD,
		0x06,0x37,0x9C,0x3B,0xAC,0xEA,0x28,0x77,0x55,0x94,0x5E,0x3B,0x7F,0x97,0x07,0xD2,
		0x58,0x1A,0xEF,0x3E,0x74,0xF4,0x23,0x94,0x97,0x4A,0xD7,0x8A,0x99,0xB1,0x6B,0x1D,
		0xA9,0xFF,0xB2,0xFE,0xBA,0x85,0x3A,0x5D,0x4F,0xD1,0x67,0x75,0x79,0x6D,0x85,0x91
	};

	int startIndex = sourceSize - HashSize;
	for(int index = 0;index < HashSize;index++)
		sourceArray[index + startIndex] = HashArray[index];
}

//复制数组
void HashAlgorithm_ByteArrayCopy (unsigned char output[], unsigned char input[], unsigned int len)
{
	for (unsigned int i = 0; i < len; i++){
		output[i] = input[i];
	}
}

void HashAlgorithm_SetByteArray (unsigned char output[], int value, unsigned int len)
{
	for (unsigned int i = 0; i < len; i++)
		((char *)output)[i] = (char)value;
}

void HashAlgorithm_Initialize()
{
	count[0] = count[1] = 0;
	state[0] = 0x67452301;
	state[1] = 0xefcdab89;
	state[2] = 0x98badcfe;
	state[3] = 0x10325476;
}

void HashAlgorithm_Update (unsigned char input[], unsigned int inputLen)
{
	unsigned int i, partLen, index= (unsigned int)((count[0] >> 3) & 0x3F);
 
	if ((count[0] += ((unsigned long int)inputLen << 3))	< ((unsigned long int)inputLen << 3))
		count[1]++;
	count[1] += ((unsigned long int)inputLen >> 29);
	partLen = 64 - index;
 
	if (inputLen >= partLen) 
	{
		HashAlgorithm_ByteArrayCopy((unsigned char*)&buffer[index],	(unsigned char*)input, partLen);
		HashAlgorithm_Transform(state, buffer);
		for (i = partLen; i + 63 < inputLen; i += 64)
			HashAlgorithm_Transform (state, &input[i]);
  
		index = 0;
	}
	else
	i = 0;

	HashAlgorithm_ByteArrayCopy ((unsigned char*)&buffer[index], (unsigned char*)&input[i], inputLen-i);
}

void HashAlgorithm_Encode (unsigned char output[], unsigned long int input[], unsigned int len)
{
	for (unsigned int i = 0, j = 0; j < len; i++, j += 4) 
	{
		output[j] = (unsigned char)(input[i] & 0xff);
		output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
		output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
		output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
	}
}

void HashAlgorithm_Decode (unsigned long int output[], unsigned char input[], unsigned int len)
{
	for (unsigned int i = 0, j = 0; j < len; i++, j += 4)
	{
		output[i] = ((unsigned long int)input[j]) | (((unsigned long int)input[j+1]) << 8) |
		(((unsigned long int)input[j+2]) << 16) | (((unsigned long int)input[j+3]) << 24);
	}
}

void HashAlgorithm_Transform (unsigned long int state[4], unsigned char block[64])
{
	 unsigned long int a = state[0], b = state[1], c = state[2], d = state[3], x[16];
	 HashAlgorithm_Decode(x, block, 64);
 
	 FF (a, b, c, d, x[ 0], S11, 0xd76aa478);
	 FF (d, a, b, c, x[ 1], S12, 0xe8c7b756);
	 FF (c, d, a, b, x[ 2], S13, 0x242070db);
	 FF (b, c, d, a, x[ 3], S14, 0xc1bdceee);
	 FF (a, b, c, d, x[ 4], S11, 0xf57c0faf);
	 FF (d, a, b, c, x[ 5], S12, 0x4787c62a);
	 FF (c, d, a, b, x[ 6], S13, 0xa8304613);
	 FF (b, c, d, a, x[ 7], S14, 0xfd469501);
	 FF (a, b, c, d, x[ 8], S11, 0x698098d8);
	 FF (d, a, b, c, x[ 9], S12, 0x8b44f7af);
	 FF (c, d, a, b, x[10], S13, 0xffff5bb1);
	 FF (b, c, d, a, x[11], S14, 0x895cd7be);
	 FF (a, b, c, d, x[12], S11, 0x6b901122);
	 FF (d, a, b, c, x[13], S12, 0xfd987193);
	 FF (c, d, a, b, x[14], S13, 0xa679438e);
	 FF (b, c, d, a, x[15], S14, 0x49b40821);
 
	 GG (a, b, c, d, x[ 1], S21, 0xf61e2562);
	 GG (d, a, b, c, x[ 6], S22, 0xc040b340);
	 GG (c, d, a, b, x[11], S23, 0x265e5a51);
	 GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa);
	 GG (a, b, c, d, x[ 5], S21, 0xd62f105d);
	 GG (d, a, b, c, x[10], S22,  0x2441453);
	 GG (c, d, a, b, x[15], S23, 0xd8a1e681);
	 GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8);
	 GG (a, b, c, d, x[ 9], S21, 0x21e1cde6);
	 GG (d, a, b, c, x[14], S22, 0xc33707d6);
	 GG (c, d, a, b, x[ 3], S23, 0xf4d50d87);
	 GG (b, c, d, a, x[ 8], S24, 0x455a14ed);
	 GG (a, b, c, d, x[13], S21, 0xa9e3e905);
	 GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8);
	 GG (c, d, a, b, x[ 7], S23, 0x676f02d9);
	 GG (b, c, d, a, x[12], S24, 0x8d2a4c8a);
 
	 HH (a, b, c, d, x[ 5], S31, 0xfffa3942);
	 HH (d, a, b, c, x[ 8], S32, 0x8771f681);
	 HH (c, d, a, b, x[11], S33, 0x6d9d6122);
	 HH (b, c, d, a, x[14], S34, 0xfde5380c);
	 HH (a, b, c, d, x[ 1], S31, 0xa4beea44);
	 HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9);
	 HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60);
	 HH (b, c, d, a, x[10], S34, 0xbebfbc70);
	 HH (a, b, c, d, x[13], S31, 0x289b7ec6);
	 HH (d, a, b, c, x[ 0], S32, 0xeaa127fa);
	 HH (c, d, a, b, x[ 3], S33, 0xd4ef3085);
	 HH (b, c, d, a, x[ 6], S34,  0x4881d05);
	 HH (a, b, c, d, x[ 9], S31, 0xd9d4d039);
	 HH (d, a, b, c, x[12], S32, 0xe6db99e5);
	 HH (c, d, a, b, x[15], S33, 0x1fa27cf8);
	 HH (b, c, d, a, x[ 2], S34, 0xc4ac5665);
  
	 II (a, b, c, d, x[ 0], S41, 0xf4292244);
	 II (d, a, b, c, x[ 7], S42, 0x432aff97);
	 II (c, d, a, b, x[14], S43, 0xab9423a7);
	 II (b, c, d, a, x[ 5], S44, 0xfc93a039);
	 II (a, b, c, d, x[12], S41, 0x655b59c3);
	 II (d, a, b, c, x[ 3], S42, 0x8f0ccc92);
	 II (c, d, a, b, x[10], S43, 0xffeff47d);
	 II (b, c, d, a, x[ 1], S44, 0x85845dd1);
	 II (a, b, c, d, x[ 8], S41, 0x6fa87e4f);
	 II (d, a, b, c, x[15], S42, 0xfe2ce6e0);
	 II (c, d, a, b, x[ 6], S43, 0xa3014314);
	 II (b, c, d, a, x[13], S44, 0x4e0811a1);
	 II (a, b, c, d, x[ 4], S41, 0xf7537e82);
	 II (d, a, b, c, x[11], S42, 0xbd3af235);
	 II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb);
	 II (b, c, d, a, x[ 9], S44, 0xeb86d391);
 
	 state[0] += a;
	 state[1] += b;
	 state[2] += c;
	 state[3] += d;
	 HashAlgorithm_SetByteArray ((unsigned char*)x, 0, sizeof (x));
}

void HashAlgorithm_Final (unsigned char digest[16])
{
	unsigned char bits[8];
	unsigned int index, padLen;
 
	HashAlgorithm_Encode (bits, count, 8);
 
	index = (unsigned int)((count[0] >> 3) & 0x3f);
	padLen = (index < 56) ? (56 - index) : (120 - index);
	HashAlgorithm_Update ( PADDING, padLen);
	HashAlgorithm_Update (bits, 8);
	HashAlgorithm_Encode (digest, state, 16);
 
	//HashAlgorithm_SetByteArray ((unsigned char*)this, 0, sizeof (*this));
	HashAlgorithm_Initialize();
}
#pragma managed